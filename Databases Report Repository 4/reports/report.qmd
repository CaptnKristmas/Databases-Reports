---
title: Homework 4 - Database Normalization
author: 
   - name: Vladimir Paraschiv
   - email: paraschivv@vcu.edu

format:
  html:
    self-contained: true
    embed-resources: true
    standalone: true
---

[Link to GITHUB Repo](https://github.com/cmsc-vcu/cmsc408-fa2025-hw4-CaptnKristmas)

Database normalization is a systematic process in relational database design aimed at organizing data efficiently while minimizing redundancy and ensuring data integrity. It involves breaking down complex tables into smaller, related tables to eliminate data anomalies and dependencies. The process consists of several normal forms, such as First Normal Form (1NF), Second Normal Form (2NF), and Third Normal Form (3NF), each addressing specific types of redundancy and dependency issues. By achieving higher normal forms, database designers create more robust, maintainable, and efficient databases that facilitate data retrieval and modification.

Functional dependencies play a pivotal role in the process of database normalization. They define the relationships between attributes within tables, enabling the identification of candidate keys—sets of attributes that can uniquely identify each row in a table. To achieve higher normal forms, such as Second Normal Form (2NF) and Third Normal Form (3NF), designers utilize functional dependencies to eliminate partial and transitive dependencies. Closures and minimum covers help in the formal analysis of these dependencies, assisting designers in identifying the minimal set of functional dependencies necessary to achieve a specific normal form. This rigorous approach to managing dependencies and achieving higher normal forms ultimately results in more efficient and well-structured databases, reducing data redundancy and the potential for anomalies.

# Quiz prep

This first section helps me prepare for the practice quiz 3 and real quiz 3.

## Tools, resources and references

* <http://raymondcho.net/RelationalDatabaseTools/RelationalDatabaseTools.html>
* <http://www.ict.griffith.edu.au/normalization_tools/normalization/ind.php>
* <https://ashutoshtripathi.com/gate/dbms/normalization-normal-forms/procedure-to-decompose-a-given-relation-in-bcnf-bcnf-algorithm/>
* <https://ecampusontario.pressbooks.pub/relationaldatabasesandmicrosoftaccess365/chapter/__unknown__-93/>
* <https://www.cs.rpi.edu/~sibel/csci4380/fall2020/recordings.html>
* <https://www.geeksforgeeks.org/first-normal-form-1nf/?ref=lbp>
* <https://www.geeksforgeeks.org/second-normal-form-2nf/?ref=lbp>
* <https://www.geeksforgeeks.org/third-normal-form-3nf/?ref=lbp>
* <https://www.geeksforgeeks.org/boyce-codd-normal-form-bcnf/?ref=lbp>

## Terms and definitions

Define the following terms. Where possible connect these definitions to other terms in the list.  Further, feel free to use algebraic notation and LaTeX to define terms where appropriate.

Relation
: A relation is a structured collection of data organized in a table containing columns and rows. These columns and rows represent attributes and tuples respectively. It also describes the connections between two or more tables which is established using primary and foreign keys.

Attribute
: A property or characteristic that describes an entity or relationship in a database or a single entry per column is a single attribute. More simply it is a column in a relation (table).

Tuple
: a single record or instance of data. Each tuple contains one value for every attribute (single entry in a column) defined in the relation. More simply it is a single row in a relation (table).

Functional dependency
: A relationship in a relation (table) where the value of one or more attributes determine the value of one or more attributes. Meaning $X \rightarrow Y$ where $X$ must have the same values for its attribute or attributes as $Y$.

Candidate Key
: An attribute or set of attributes that can uniquely identify each record/tuple (row) and is the minimum set required. It is a candidate due to be a potential selection for the primary key. It must follow two properties, uniqueness and minimality. Meaning no two tuples in relation $R$ have the same values for attribute/attributes $K$ and no proper subset of attribute/attributes $K$ has the uniqueness property. 

Primary Key
: An attribute or set of attributes that can uniquely identifies each record/tuple (row) and is the minimum set required. This becomes the official idetifier. It differs from being a candidate key due to there only being one allowed primary key per record or tuple. Thus, it must follow the same properties of uniqueness and minimality as above. The other candidate keys for each record/tuple become alternate keys.

Super Key
: An attribute or set of attributes that can uniquely identifies each record/tuple (row). Candidate keys and primary keys are special types of super keys. This differs due to it not having to be the minimum set. Meaning the set of all tuples in the relation is included as a superkey. As such $Super Keys \rightarrow Candidate Keys \rightarrow Primary Keys$. 

Composite Key
: A key made up of two or more attributes that together uniquely identify a record/tuple (row) in a relation (table); but no single attribute is sufficient for uniqueness. More simply, a set of attributes that are required to be a set to identify the uniqueness of that record/tuple. This means many super keys are composite keys. 

Prime attributes
: Any attribute that is a part of the candidate key in a relation (table). If an attribute uniquely identifies a record/tuple (row), it is prime.

Non-prime attributes
: Any attribute that is not a apart of the candidate key in a relation (table). If the attribute cannot uniquely identify a record/tuple (row), it is not prime.

Armstrong’s axioms
: A set of fundemental inference rules used to derive all possible functional dependencies that hold in a relation. They were proposed by William W. Armstong in 1974.

- Reflexivity: Any set of attributes determines its own subset. If $Y \subseteq X$ then $X \rightarrow Y$
- Augmentation: You can add attributes to both sides and the dependency still holds. If $X \rightarrow Y$, then $XZ \rightarrow YZ$ (for any $Z$)
- Transitivity: Dependencies can chain through intermediate sets. If $X \rightarrow Y$ and $Y \rightarrow Z$, then $X \rightarrow Z$

Partial Dependency
: They occur when non-prime attributes depend on a subset (part) of a composite key, rather than on the whole key. One of the issues a 2NF aims to eliminate.

Transitive Dependency
: A type of functional dependency that occurs when a non-prime attribute depends on another non-prime attribute, rather then directly on a candidate key.

A transitive dependency exits in a in a relation $R$ if there are attributes, $A$,$B$, and $C$ such that:
    1. $A \rightarrow B$ and $B \rightarrow C$
    2. $A$ is candidate key (or superkey)
    3. $C$ is a non-prime attribute meaning $C$ is transitively dependent on $A$ through $B$.

Attribute Closure
: Also called the closure of a set of attributes. It is a set of all attributes that can be functionally determined from a given set of attributes using a given set of functional dependencies. $X^+$: all attributes you can determine starting from $X$, by repeatedly applying the known functinal dependencies.

Decomposition
: The process of breaking a relation (table) into two or more smaller relations in order to reduce redundancy, eliminate anomalies, and preserve date consistency; while ensuring that no information is lost. In other words, we split a large relation into smaller, well-structured ones, each representing a more precise concept. This must be done to achieve higher normal forms.

Lossless decomposition 
: A type of decomposition in which a relation (table) is split into two or more smaller relations. When these smaller relations are joined back together, the original relation is perfecntly reconstructed, without any loss or gain of information. A decomposition of a relation $R$ into $R_1$ and $R_2$ is lossless if the natural join of $R_1$ and $R_2$ gives back exactly $R$.

Denormalization
: The process of intentionally combining tables or re-introducing redundancy into a normalized database to improve performance, typically in query speed or data retrieval efficiency.

Trivial functional dependencies 
: A dependency that is always true because the right-hand side is a subset of the left-hand side. A functional dependency $X \rightarrow Y$ is trivial if $Y \subseteq X$. Meaning the attributes on the right-hand side are already included in those on the left, so the dependency does not tell us anything new about the data.

Closure of a set of FDs 
: It is denoted by $F^+$, is the set of all FD's that can be logically inferred from a given set F, using Atmstrong's Axioms (Reflexivity, Augmentation, and Transitivity) and all rules derived from them.

Minimum cover
: A minimum cover is the smallest possible version of a set of FD;s that means exacly the same thing, its just the "cleaned-up" form.

First normal form (1NF)
: Requires one to atomasize all the values.

Second normal form (2NF)
: Must meet the 1NF requirements and have no partial dependencies.

Third normal form (3NF)
: Must meet the 2NF requirements and have no transitive dependencies.

Boyce Codd normal form (BCNF)
: Must meet the 3NF requirements and for every FD $X \rightarrow Y$, $X$ must be a superkey (no exceptions).

Fourth normal form (4NF)
: Must meet the BCNF requirements and it must have no non-trivial multivalued dependencies other than those that are implied by a candidate key.

## Practice with closures and normal forms.

Use the [Cho Calculator](http://raymondcho.net/RelationalDatabaseTools/RelationalDatabaseTools.html) to answer the following questions:

Given the relation $R(A,B,C,D,E,F,G)$ and the set of functional dependencies $F ({A \rightarrow B, BC \rightarrow D, D \rightarrow E, F \rightarrow G})$:

1. What is the closure of $AB$, that is, $(AB)^+$?

    $(A,B)$

1. What is $(ABC)^+$?

    $(A,B,C,D,E)$

1. What is $(ACE)^+$?

    $(A,C,E)$

1. How many candidate keys were found?

    $(2)$

1. How many superkeys were found?

    $(4)$

1. What is the list of prime attributes?

    $(A,C,F)$

1. What is the list of non-prime attributes?

    $(B,D,E,G)$

1. What is minimal cover set?

    $(A \rightarrow B, BC \rightarrow D, D \rightarrow E, F \rightarrow G)$

1. What is the normal form of the input relation $R$?

    $(2NF)$

1. What is the BCNF decomposition of $R$?

    $R_{0}(A,B) having FD(s): $A \rightarrow B$
    $R_1(B,C,D,E) FD: BC \rightarrow D, \rightarrow E$
    $R_2(F,G) FD: F \rightarrow G$

# Worked Problems

The next tasks give practice with the normalization calculator.

## Task 1 - Decompose to BCNF

Use the [Cho Calculator](http://raymondcho.net/RelationalDatabaseTools/RelationalDatabaseTools.html), decompose the following relation to BCNF:

| RID | Course Code | Course Name       | First   | Last      | Language   |
|---|-------------|-------------------|---------|-----------|------------|
| 1 | CMSC508     | Databases         | John    | Leonard   | SQL        |
| 1 | CMSC508     | Databases         | John    | Leonard   | Python     |
| 1 | CMSC508     | Databases         | John    | Leonard   | Perl       |
| 2 | CMSC508     | Databases         | Alberto | Cano      | SQL        |
| 2 | CMSC508     | Databases         | Alberto | Cano      | Python     |
| 2 | CMSC508     | Databases         | Alberto | Cano      | C++        |
| 3 | CMSC475     | UI/UX design      | John    | Leonard   | Javascript |
| 3 | CMSC475     | UI/UX design      | John    | Leonard   | Python     |
| 4 | CMSC441     | Capstone          | Bob     | Dahlberg  | COBOL      |
| 4 | CMSC441     | Capstone          | Bob     | Dahlberg  | FORTRAN    |
| 5 | CMSC320     | Data Structures   | Sarah   | Adams     | C++        |
| 5 | CMSC320     | Data Structures   | Sarah   | Adams     | Java       |
| 5 | CMSC320     | Data Structures   | Sarah   | Adams     | Python     |
| 6 | CMSC210     | Software Design   | Michael | Turner    | Java       |
| 6 | CMSC210     | Software Design   | Michael | Turner    | C#         |
| 7 | CMSC515     | Computer Vision   | Emily   | Parker    | Python     |
| 7 | CMSC515     | Computer Vision   | Emily   | Parker    | MATLAB     |
| 8 | CMSC430     | Web Development   | Jessica | Clark     | HTML       |
| 8 | CMSC430     | Web Development   | Jessica | Clark     | CSS        |
| 8 | CMSC430     | Web Development   | Jessica | Clark     | JavaScript |
| 9 | CMSC610     | Machine Learning  | Alberto | Cano      | Python     |
| 9 | CMSC610     | Machine Learning  | Alberto | Cano      | R          |

1. Write the relation above using relational algebraic notation:

    $R(RID,CourseCode,CourseName,First,Last,Language)$

1. Decompose the relation above and write the BCNF relations here, along with the FD(s) for the relation:

    $R_0(CourseCode, CourseName)$ having FD(s) $CourseCode \rightarrow CourseName$  
    $R_1(RID, First, Last CourseCode)$ having FD(s) $RID \rightarrow Last; RID \rightarrow First; RID \rightarrow CourseCode$  
    $R_2(RID, Language)$ having FD(s) (none)


## Task 2 - Decompose to BCNF

Using the Cho calculator, decompose the following relation to BCNF:

| RID | CID | Course Code |  Course Name      | PID  | First   | Last      | LID  | Language   |
|-----|-----|-------------|-------------------|------|---------|-----------|------|------------|
| 1   |  1  | CMSC508    |  Databases         |  1   | John    | Leonard   |  1   | SQL        |
| 1   |  1  | CMSC508    |  Databases         |  1   | John    | Leonard   |  2   | Python     |
| 1   |  1  | CMSC508    |  Databases         |  1   | John    | Leonard   |  3   | Perl       |
| 2   |  1  | CMSC508    |  Databases         |  2   | Alberto | Cano      |  1   | SQL        |
| 2   |  1  | CMSC508    |  Databases         |  2   | Alberto | Cano      |  2   | Python     |
| 2   |  1  | CMSC508    |  Databases         |  2   | Alberto | Cano      |  4   | C++        |
| 3   |  2  | CMSC475    |  UI/UX design      |  1   | John    | Leonard   |  5   | Javascript |
| 3   |  2  | CMSC475    |  UI/UX design      |  1   | John    | Leonard   |  2   | Python     |
| 4   |  3  | CMSC441    |  Capstone          |  3   | Bob     | Dahlberg  |  6   | COBOL      |
| 4   |  3  | CMSC441    |  Capstone          |  3   | Bob     | Dahlberg  |  7   | FORTRAN    |
| 5   |  4  | CMSC320    |  Data Structures   |  4   | Sarah   | Adams     |  4   | C++        |
| 5   |  4  | CMSC320    |  Data Structures   |  4   | Sarah   | Adams     |  8   | Java       |
| 5   |  4  | CMSC320    |  Data Structures   |  4   | Sarah   | Adams     |  2   | Python     |
| 6   |  5  | CMSC210    |  Software Design   |  5   | Michael | Turner    |  8   | Java       |
| 6   |  5  | CMSC210    |  Software Design   |  5   | Michael | Turner    |  9   | C#         |
| 7   |  6  | CMSC515    |  Computer Vision   |  6   | Emily   | Parker    |  2   | Python     |
| 7   |  6  | CMSC515    |  Computer Vision   |  6   | Emily   | Parker    |  10  | MATLAB     |
| 8   |  7  | CMSC430    |  Web Development   |  7   | Jessica | Clark     |  11  | HTML       |
| 8   |  7  | CMSC430    |  Web Development   |  7   | Jessica | Clark     |  12  | CSS        |
| 8   |  7  | CMSC430    |  Web Development   |  7   | Jessica | Clark     |  5   | JavaScript |
| 9   |  8  | CMSC610    |  Machine Learning  |  2   | Alberto | Cano      |  2   | Python     |
| 9   |  8  | CMSC610    |  Machine Learning  |  2   | Alberto | Cano      |  13  | R          |


The table above contains responses from a survey.  The survey asked for the course code and name, the instructor first and last name, and the computer languages known by the instructor.

1. Write the relation above using relational algebraic notation:

    $R(RID,CID,CourseCode,CourseName,PID,First,Last,LID,Language)$

1. Write the functional dependencies in the same notation:

    $FD(RID \rightarrow CID,PID; CID \rightarrow CourseCode,CourseName; PID \rightarrow First,Last; LID \rightarrow Language)$

1. Decompose the relation above and write the BCNF relations here, along with the FD(s) for the relation:

    $R_0(CID, CourseCode, CourseName)$ having FD(s): $CID \rightarrow CourseCode; CID \rightarrow CourseName$  
    $R_1(LID, Language)$ having FD(s) $LID \rightarrow Language$  
    $R_2(PID, Last, First)$ having FD(s) $PID \rightarrow Last; PID \rightarrow First$  
    $R3(CID, PID, RID)$ having FD(s) $RID \rightarrow CID; RID \rightarrow PID$  
    $R4(LID, RID)$ having FD(s): (none)

## Task 3 - Decompose to BCNF

Use the [Cho Calculator](http://raymondcho.net/RelationalDatabaseTools/RelationalDatabaseTools.html), decompose the following relation to BCNF:

| Group  | Artist   | Genre     | DateFounded | DateJoined |
|--------|----------|-----------|-------------|------------|
| Queen  | Mercury  | Pop/Rock  | 1971        | 1971       |
| Queen  | May      | Pop/Rock  | 1971        | 1972       |
| Queen  | Taylor   | Pop/Rock  | 1971        | 1971       |
| Queen  | Deacon   | Pop/Rock  | 1971        | 1972       |
| Beatles| Lennon   | Pop/Rock  | 1960        | 1960       |
| Beatles| McCartney| Pop/Rock  | 1960        | 1960       |
| Beatles| Starr    | Pop/Rock  | 1960        | 1960       |
| Beatles| Harrison | Pop/Rock  | 1960        | 1960       |

The relation above lists a music group and artist and the date the artist joined the group.  Further,
the table highlights the genre of music played by the group and date the group was founded.

1. Write the relation above using relational algebraic notation:

    $R(Group,Artist,Genre,DateFounded,DateJoined)$

1. Write the functional dependencies in the same notation:

    $FD(Group \rightarrow Genre, DateFounded; Group,Artist \rightarrow DateJoined)$

1. Decompose the relation above and write the BCNF relations here, along with the FD(s) for the relation:

    $R_0(Genre, Group, DateFounded)$ having FD(s) $Group \rightarrow Genre; Group \rightarrow DateFounded$  
    $R_1(Group, Artist, DateJoined)$ having FD(s) $GROUP, ARTIST \rightarrow DATEJOINED$  

## Task 4 - Normalizing a Pizza Delivery Database

Your friend owns a pizza shop and asked you to help tune their database. They continue to
encounter miscoded data and believe that you DB expertise can save them time and effort
cleaning the data.

Customer table (This table is already BCNF. Do not decompose Name.)

| CustID | Name            | Address              | City         | State | Zip     | Phone          |
|--------|-----------------|----------------------|--------------|-------|---------|----------------|
| 101    | John Smith      | 123 Main St          | New York     | NY    | 10001   | (555) 123-4567 |
| 102    | Mary Johnson    | 456 Elm St           | Los Angeles  | CA    | 90002   | (555) 987-6543 |
| 103    | David Brown     | 789 Oak Ave          | Chicago      | IL    | 60603   | (555) 567-8901 |
| 104    | Sarah Davis     | 101 Pine Rd          | Houston      | TX    | 77001   | (555) 234-5678 |
| 105    | Michael Wilson  | 321 Cedar Blvd       | Miami        | FL    | 33102   | (555) 876-5432 |


Order table

| OrderID | Date       | CustID | PieNum | Size   | ToppingCode | ToppingDesc   | PickupOrDelivery  |
|---------|------------|--------|--------|--------|-------------|---------------|-------------------|
| 1001    | 2023-09-01 | 101    | 1      | Medium | PEP         | Pepperoni     | Pickup            |
| 1001    | 2023-09-01 | 101    | 2      | Large  | MUS         | Mushrooms     | Pickup            |
| 1002    | 2023-09-01 | 104    | 1      | Large  | SAU         | Sausage       | Delivery          |
| 1002    | 2023-09-01 | 104    | 1      | Large  | PEP         | Pepperoni     | Delivery          |
| 1002    | 2023-09-01 | 104    | 1      | Large  | MUS         | Mushrooms     | Delivery          |
| 1002    | 2023-09-01 | 104    | 2      | Small  | SAU         | Sausage       | Delivery          |
| 1005    | 2023-09-02 | 103    | 1      | Medium | PEP         | Pepperoni     | Pickup            |
| 1005    | 2023-09-02 | 103    | 1      | Large  | MUS         | Mushrooms     | Pickup            |
| 1011    | 2023-09-02 | 102    | 1      | Small  | SAU         | Sausage       | Pickup            |
| 1011    | 2023-09-02 | 102    | 2      | Medium | PEP         | Pepperoni     | Pickup            |
| 1011    | 2023-09-02 | 102    | 3      | Large  | MUS         | Mushrooms     | Pickup            |
| 1013    | 2023-09-13 | 104    | 1      | Small  | SAU         | Sausage       | Delivery          |
| 1013    | 2023-09-13 | 104    | 1      | Small  | PEP         | Pepperoni     | Delivery          |
| 1013    | 2023-09-13 | 104    | 2      | Large  | MUS         | Mushrooms     | Delivery          |
| 1013    | 2023-09-13 | 104    | 2      | Large  | SAU         | Sausage       | Delivery          |


1. Using the Cho calculator, refactor the table above to smaller BCNF tables. Show your results.
  
    $R_0(Date, CustID, OrderID, PickupOrDelivery)$ having FD(s) $OrderID \rightarrow Date; OrderID \rightarrow CustID; OrderID \rightarrow PickupOrDelivery$  
    $R_1(ToppingCode, ToppingDesc)$ having FD(s) $ToppingCode \rightarrow ToppingDesc$  
    $R_2(Size, PieNum, OrderID)$ having FD(s) $PieNum,OrderID \rightarrow Size$  
    $R_3(PieNum, OrderID, ToppingCode)$ having FD(s): (none)  

*Hint* - the refactoring should result in four tables: *orders*, *pie*, *topping*, *order-pie-topping*, plus the *customer* table already provided.

1. Now, use ChatGPT to create actual data tables using the data above.  Starting with an fresh session, use the query:

    Hey Chatgpt, normalize the table below into BCNF form: (shift-enter)
    (then paste the table into chatgpt.)

#### Table 1: Orders

This table captures order-related information.

| OrderID | Date       | CustID | PickupOrDelivery |
|---------|------------|--------|------------------|
| 1001    | 2023-09-01 | 101    | Pickup           |
| 1002    | 2023-09-01 | 104    | Delivery         |
| 1005    | 2023-09-02 | 103    | Pickup           |
| 1011    | 2023-09-02 | 102    | Pickup           |
| 1013    | 2023-09-13 | 104    | Delivery         |

#### Table 2: Pies

This table captures information about pies ordered.

|   ToppingCode   |   ToppingDesc   |
| --------------- | --------------- |
| PEP             | Pepperoni       |
| MUS             | Mushrooms       |
| SAU             | Sausage         |


#### Table 3: Toppings

This table captures topping-related information.

|   OrderID   |   PieNum   |   Size   |
| ----------- | ---------- | -------- |
| 1001        | 1          | Medium   |
| 1001        | 2          | Large    |
| 1002        | 1          | Large    |
| 1002        | 2          | Small    |
| 1005        | 1          | Medium   |
| 1005        | 1          | Large    |
| 1011        | 1          | Small    |
| 1011        | 2          | Medium   |
| 1011        | 3          | Large    |
| 1013        | 1          | Small    |
| 1013        | 2          | Large    |


#### Table 4: Pie Toppings

This table relates pies to their toppings.

|   OrderID   |   PieNum   |   ToppingCode   |
| ----------- | ---------- | --------------- |
| 1001        | 1          | PEP             |
| 1001        | 2          | MUS             |
| 1002        | 1          | SAU             |
| 1002        | 1          | PEP             |
| 1002        | 1          | MUS             |
| 1002        | 2          | SAU             |
| 1005        | 1          | PEP             |
| 1005        | 1          | MUS             |
| 1011        | 1          | SAU             |
| 1011        | 2          | PEP             |
| 1011        | 3          | MUS             |
| 1013        | 1          | SAU             |
| 1013        | 1          | PEP             |
| 1013        | 2          | MUS             |
| 1013        | 2          | SAU             |



## Task 5 - Relational Algebra Queries

These are really tough and require a lot of thought.  You can also use ChatGPT, but you'll find that you've got to know
enough about what's going on to snip out what you need for the solution.

*Hint* - Task 4 (above) should result in four tables: *order*, *pie*, *topping*, *order-pie-topping*, plus the *customer* table already provided.  You should use these names when writing your relational queries below.

1. Who ordered the most pizzas?  Write the relational algebraic steps, one at a time:

    $R_1 := (Orders \bowtie Pies)$ # Join to label each pie with its customer (via OrderID).

    $R_2 := \gamma_{CustID;\ \mathrm{COUNT}(PieNum)\rightarrow pizzaCount}(R_1)$ # Group by customer and count how many pies they ordered across all orders. 

    $R_3 := \gamma_{\ ;\ \mathrm{MAX}(pizzaCount)\rightarrow m}(R_2)$ # Compute the maximum pies ordered by any customer.

    $R_4 := \pi_{CustID,\ pizzaCount}\big(\sigma_{pizzaCount = m}(R_2 \times R_3)\big)$ # Keep the customer(s) whose count equals the maximum (ties allowed).

ANSWER CustID 104 or Sarah Davis

1. Which was the most popular ingredient?  Write the relational algebraic steps, one at a time:

    $R_1 := (PieToppings \bowtie Toppings)$  # Join the PieToppings and Toppings tables so each topping code is paired with its description.

    $R_2 := \gamma_{ToppingDesc;\ \mathrm{COUNT}(*) \rightarrow count}(R_1)$  # Group by topping description and count how many times each topping appears across all pies.

    $R_3 := \gamma_{\ ;\ \mathrm{MAX}(count) \rightarrow maxCount}(R_2)$ # Compute the maximum frequency (maxCount) among all toppings.

    $R_4 := \pi_{ToppingDesc,\ count}\big(\sigma_{count = maxCount}(R_2 \times R_3)\big)$ # Select and display the topping(s) whose count equals the maximum — i.e., the most popular topping(s).

ANSWER Pepperoni, Mushrooms, Sausage

1. Who placed the most orders?  Write the relational algebraic steps, one at a time:

    $R_1 := ORDERS$ # Starts with the Orders relation that lists all custmer orders. 

    $R_2 := \gamma_{CustID;\ \mathrm{COUNT}(OrderID)\rightarrow numOrders}(R_1)$ # Group by CustID and count the number of orders each customer has placed.

    $R_3 := \gamma_{\ ;\ \mathrm{MAX}(numOrders)\rightarrow m}(R_2)$ # Find the maximum number of orders among all customers.

    $R_4 := \pi_{CustID,\ numOrders}\big(\sigma_{numOrders = m}(R_2 \times R_3)\big)$ # Select and project the customer(s) whos order count equals the maximum.

ANSWER CustID 104 or Sarah Davis

1. What was the most popular size?  Write the relational algebraic steps, one at a time:

    $R_1 := (Pies)$ # Start with the PIES relation, which contains all pizza sizes for each pie in every order.
    
    $R_2 := \gamma_{Size;\ \mathrm{COUNT}(*) \rightarrow cnt}(R_1)$ # Group by each distinct Size and count how many times each size occurs across all pies.

    $R_3 := \gamma_{\ ;\ \mathrm{MAX}(cnt) \rightarrow m}(R_2)$ # Compute the maximum count value (m), representing the most frequent size.

    $R_4 := \pi_{Size,\ cnt}\big(\sigma_{cnt = m}(R_2 \times R_3)\big)$ # Select the size(s) whose count equals the maximum value, giving the most popular size.

ANSWER Large

1. Which day was the greater number of pizzas made?  Write the relational algebraic steps, one at a time:

    $R_1 := (Orders \bowtie Pies)$ # Join the ORDERS and PIES tables so each pie record includes its order date.
    
    $R_2 := \gamma_{Date;\ \mathrm{COUNT}(PieNum) \rightarrow cnt}(R_1)$  # Group by Date and count how many pies (PieNum) were made on each date.

    $R_3 := \gamma_{\ ;\ \mathrm{MAX}(cnt) \rightarrow m}(R_2)$ # Compute the maximum number of pies (m) made on any single date.

    $R_4 := \pi_{Date,\ cnt}\big(\sigma_{cnt = m}(R_2 \times R_3)\big)$ # Select the date(s) whose pie count equals the maximum value, i.e., the busiest pizza day.

ANSWER 2023-09-02

# Reflection

What was most difficult about this assignment?
: The relational algebra proved the most difficult to understand and process.

What was easiest about this assignment?
: The Cho calculator was by far the easiest to use.

Do you have any suggestions for helping future students learn normalization?
: Chat GPT does a great job of breaking down what is needed for every step of normalization. That way one can better understand normalization.


# README

Below is the README from my project.

::: {style="background:lightgray; margin-left:20px; border-top: 3px solid black; border-bottom: 3px solid black; padding-left:20px; padding-right:20px"}
{{< include ../README.md >}}
:::


